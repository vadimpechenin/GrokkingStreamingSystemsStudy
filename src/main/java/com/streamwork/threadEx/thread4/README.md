## Часть IV — Callable, Future и друзья

# 1. java.util.concurrent.Callable

Оказывается, у java.lang.Runnable есть брат и зовут его java.util.concurrent.Callable и появился он на свет в Java 1.5. В чём же различия? Если приглядеться к JavaDoc этого интерфейса, мы видим, что в отличие от Runnable, новый интерфейс объявляет метод call, который возвращает результат. Кроме того, по умолчанию он throws Exception. То есть избавляет нас от необходимости на проверяемые исключения писать try-catch блоки. Уже неплохо, правда?

Теперь у нас есть вместо Runnable новый task:

Callable task = () -> {
return "Hello, World!";
};

Но что с ним делать? Зачем нам вообще задача, выполняемая в потоке, которая возвращает результат? Очевидно, что в дальнейшем мы рассчитываем получить результат действий, которыев в будущем будут выполнены. Будущее по-английский — Future. И интерфейс есть с точно таким же именем: java.util.concurrent.Future

# 2. java.util.concurrent.Future 

Интерфейс java.util.concurrent.Future описывает API для работы с задачами, результат которых мы планируем получить в будущем: методы получения результата, методы проверки статуса.

Для Future нас интересует его реализация java.util.concurrent.FutureTask. То есть это Task, который будет выполнен во Future. Чем эта реализация ещё интересна, так это тем, что она реализует и Runnable. Можно считать это своего рода адаптером старой модели работы с задачами в потоках и новой модели (новой в том смысле, что она появилась в java 1.5).

Получаем при помощи метода get результат из задачи task.

(!)Важно, что в момент получения результата при помощи метода get выполнение становится синхронным. Как вы думаете, какой механизм тут будет использован? Правильно, нет блока синхронизации — поэтому WAITING в JVisualVM мы увидим не как monitor или wait, а как тот самый park (т.к. используется механизм LockSupport).

# 3. Функциональные интерфейсы
Дальше пойдёт речь про классы из Java 1.8, поэтому не лишним будет сделать краткое введение. Посмотрим на следующий код:

Supplier<String> supplier = new Supplier<String>() {<br />
@Override<br />
public String get() {<br />
return "String";
}<br />
};<br />

Consumer<String> consumer = new Consumer<String>() {<br />
@Override<br />
public void accept(String s) {<br />
System.out.println(s);
}<br />
};<br />

Function<String, Integer> converter = new Function<String, Integer>() {<br />
@Override<br />
public Integer apply(String s) {<br />
return Integer.valueOf(s);
}<br />
};<br />

Как же много лишнего кода, не правда ли? Каждый из объявляемых классов выполняет какую-то одну функцию, но для её описания мы используем кучу лишнего вспомогательного кода. И разработчики Java так же подумали. Поэтому, они ввели набор "функциональных интерфейсов" (@FunctionalInterface) и решили, что теперь Java сама будет "додумывать" за нас всё, кроме важного:
Supplier<String> supplier = () -> "String";<br />
Consumer<String> consumer = s -> System.out.println(s);<br />
Function<String, Integer> converter = s -> Integer.valueOf(s);<br />

Supplier — поставщик. Он не имеет параметров, но возвращает что-то, то есть поставляет это.

Consumer — потребитель. Он принимает на вход что-то (параметр s) и с этим что-то что-то делает, то есть потребляет что-то.

Есть ещё функция. Она принимает на вход что-то (параметр s), что-то делает и возвращает что-то. Как мы видим, активно используются дженерики.

# 4. CompletableFuture - CompletableFutureEx; ServiceWithCompletableFuture + NewService; CompletableFutureReturn; CompletableFutureException
Шло время, и в Java 1.8 появился новый класс, который зовётся CompletableFuture. Он реализует интерфейс Future, то есть наши task будут выполнены в будущем, и мы сможем выполнить get и получить результат. Но ещё он реализует некоторый CompletionStage. Из перевода уже понятно его назначение: это некий этап (Stage) каких-то вычислений. 

Если мы выполним код CompletableFutureEx, то увидим, что создание CompletableFuture подразумевает запуск и всей цепочки. Поэтому при некоторой схожести со SteamAPI из Java8 в этом отличие этих подходов.

StreamAPIEx.java -  пример Java 8 Stream Api (подробнее можно с ним ознакомиться здесь "Руководство по Java 8 Stream API в картинках и примерах"). Если запустить этот код, то Executed не отобразится. То есть при создании стрима в Java стрим не запускается сразу, а ждёт, когда из него захотят значение. А вот CompletableFuture запускает цепочку на выполнение сразу, не дожидаясь того, что у него попросят посчитанное значение. Считаю важным это понимать.

Итак, у нас есть CompletableFuture. Как же мы можем составить цепочку и какие у нас есть средства?

Вспомним про функциональные интерфейсы, о которых мы писали ранее.
У нас есть функция (Function), которая принимает А и возвращает Б. Имеет единственный метод — apply (применить).
У нас есть потребитель (Consumer), которая принимает А и ничего не возвращает (Void). Имеет единственный метод — accept (принять).
У нас есть запускаемый в потоке код Runnable, который не принимает и не возвращает. Имеет единственный метод — run (запустить).
Второе, что надо помнить, что CompletalbeFuture в своей работе использует Runnable, потребителей и функции. Учитывая это, вы всегда сможете вспомнить, что с CompletableFuture можно делать так, как показано в CompletableFutureEx2.

У методов thenRun, thenApply и thenAccept есть версии Async. Это значит, что эти стадии будут выполнены в новом потоке. Он будет взят из особого пула, поэтому заранее неизвестно, какой поток будет, новый или прежний. Всё зависит от того, на сколько тяжёлые задачи.

Помимо этих методов есть ещё три интересные возможности.

Пример ServiceWithCompletableFuture (со статическим вложенным классом NewService): Для наглядности представим, что у нас есть некий сервис, который получает какое-то сообщение откуда-то и на это требуется время
Теперь, давайте посмотрим на другие возможности, которые предоставляет CompletableFuture. Мы можем объединять результат CompletableFuture с результатом другого CompletableFuture.
Тут стоить обратить внимание, что по умолчанию потоки будут демон-потоками, поэтому для наглядности мы используем get, чтобы дождаться результат.

А ещё мы можем не только объединить (combine), но и возвращать CompletableFuture (CompletableFutureReturn).
Тут хочется отметить, что для краткости использован метод CompletableFuture.completedFuture. Данный метод не создаёт новый поток, поэтому остальная цепочка будет выполнена в том же потоке, в котором был вызван completedFuture.

Также есть метод thenAcceptBoth. Он очень похож на accept, но если thenAccept принимает consumer, то thenAcceptBoth принимает на вход ещё один CompletableStage + BiConsumer, то есть consumer, который на вход принимает 2 источника, а не один.

Есть ещё интересная возможность со словом Either. Данные методы принимают альтернативный CompletableStage и будут выполнены на том CompletableStage, который первее выполнится.

И закончить этот обзор хочется ещё одной интересной возможностью CompletableFuture — обработкой ошибок (CompletableFutureReturn). Данный код ничего не сделает, т.к. упадёт исключение и ничего не будет. Но если мы раскомментируем exceptionally, то мы определим поведение.


