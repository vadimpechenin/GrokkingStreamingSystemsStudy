## Часть VI — К барьеру!

# 1. Семафоры - SemaphoreEx

Самое простое средство контроля за тем, сколько потоков могут одновременно работать — семафор. Как на железной дороге. Горит зелёный — можно. Горит красный — ждём. Что мы ждём от семафора? Разрешения. Разрешение на английском — permit. Чтобы получить разрешение — его нужно получить, что на английском будет acquire. А когда разрешение больше не нужно мы его должны отдать, то есть освободить его или избавится от него, что на английском будет release. Посмотрим, как это работает.

Нам потребуется импорт класса java.util.concurrent.Semaphore.

Как видим, запомнив английские слова, мы понимаем, как работает семафор. Интересно, что главное условие — на "счету" семафора должен быть положительное количество permit'ов. Поэтому, инициировать его можно и с минусом. И запрашивать (acquire) можно больше, чем 1.

# 2. CountDownLatch  - CountDownLatchEx

Следующий механизм — CountDownLatch. CountDown на английском — это отсчёт, а Latch — задвижка или защёлка. То есть если переводить, то это защёлка с отсчётом.

Тут нам понадобится соответствующий импорт класса java.util.concurrent.CountDownLatch.

Это похоже на бега или гонки, когда все собираются у стартовой линии и когда все готовы — дают разрешение, и все одновременно стартуют.

await на английском — ожидать. То есть мы сначала говорим countDown. Как говорит гугл переводчик, count down — "an act of counting numerals in reverse order to zero", то есть выполнить действие по обратному отсчёту, цель которого — досчитать до нуля. А дальше говорим await — то есть ожидать, пока значение счётчика не станет ноль.

Интересно, что такой счётчик — одноразовый. Как сказано в JavaDoc — "When threads must repeatedly count down in this way, instead use a CyclicBarrier", то есть если нужен многоразовый счёт — надо использовать другой вариант, который называется CyclicBarrier.

# 3. CyclicBarrier - CyclicBarrierEx

Как и следует из названия, CyclicBarrier — это циклический барьер.
Нам понадобится импорт класса java.util.concurrent.CyclicBarrier.
Как видим, поток выполняет await, то есть ожидает. При этом уменьшается значение барьера. Барьер считается сломанным (berrier.isBroken()), когда отсчёт дошёл до нуля.

Чтобы сбросить барьер, нужно вызвать berrier.reset(), чего не хватало в CountDownLatch.

# 4. Exchanger - ExchangerEx и ExchangerEx2

Следующее средство — Exchanger. Exchange с английского переводится как обмен или обмениваться. А Exchanger — обменник, то есть то, через что обмениваются.

Тут мы запускаем два потока. Каждый из них выполняет метод exchange и ожидает, когда другой поток так жевыполнит метод exchange. Таким образом, потоки обменяются между собой переданными аргументами.

Интересная штука. Ничего ли она вам не напоминает?

А напоминает он SynchronousQueue, которая лежит в основе cachedThreadPool'а. Для наглядности — пример ExchangerEx2.

В примере видно, что запустив новый поток, данный поток уйдёт в ожидание, т.к. в очереди будет пусто. А дальше main поток положит в очередь текст "Message". При этом он сам остановится на время, которой нужно, пока не получат из очереди этот текстовый элемент.

# 5. Phaser - PhaserEx

И напоследок самое сладкое — Phaser.

Нам понадобится импорт класса java.util.concurrent.Phaser.

Из примера видно, что барьер при использовании Phaser'а прерывается, когда количество регистраций совпадает с количеством прибывших к барьеру.

Основные управляющие методы:<br />
   register()	- зарегистрировать участника<br />
   arrive()	- сообщить этапщику о своей готовности, не ожидая открытия барьера<br />
   arriveAndAwaitAdvance()	- классическое прибытие на барьер. Точный аналог CyclicBarrier.await()<br />
   arriveAndDeregister()	- отменить свое участие<br />



