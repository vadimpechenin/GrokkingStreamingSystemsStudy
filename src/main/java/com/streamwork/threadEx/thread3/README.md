## Часть III — взаимодействие

# 1. Deadlock

Самой страшной проблемой является Deadlock. Когда два и более потоков вечно ожидают друг друга — это называется Deadlock.

Поток 1 ждёт лока от потока 0. Почему так выходит? Thread-1 начинает выполнение и выполняет метод Friend#bow. 
Он помечен ключевым словом synchronized, то есть мы забираем монитор по this. Мы на вход в метод получили ссылку на другого Friend. 
Теперь, поток Thread-1 хочет выполнить метод у другого Friend, тем самым получив лок и у него. Но если другой поток (в данном случае Thread-0) 
успел войти в метод bow, то лок уже занят и Thread-1 ждёт Thread-0, и наоборот. Блокировка неразрешимая, поэтому она Dead, то есть мёртвая. Как мёртвая хватка (которую не разжать), 
так и мёртвая блокировка, из которой не выйти.

# 2. Livelock 

Если есть Deadlock, то есть ли Livelock? Да, есть ) Livelock заключается в том, что потоки внешне как бы живут, но при этом не могут ничего сделать, т.к. условие, по которым они пытаются продолжить свою работу, не могут выполниться. По сути Livelock похож на deadlock, но только потоки не "зависают" на системном ожидании монитора, а что-то вечно делают.

Успешность этого кода зависит от того, в каком порядке планировщик потоков Java запустит потоки.

Если первым запустится Thead-1, то мы получим Livelock:
оба потока поочерёдно пытаются захватить оба лока, но им это не удаётся. При этом они не в deadlock, то есть визуально с ними всё хорошо и они выполняют свою работу. По JVisualVM мы видим периоды sleep и период park (это когда поток пытается занять лок, он переходит в состояние park, как мы разбирали ранее, говоря про синхронизацию потоков).


# 3. Starvation - StarvationDemo и FairnessDemo
Помимо блокировок (deadlock и livelock) есть ещё одна проблема при работе с многопоточностью — Starvation, или "голодание". От блокировок это явление отличается тем, что потоки не заблокированы, а им просто не хватает ресурсов на всех. Поэтому пока одни потоки на себя берут всё время выполнения, другие не могут выполниться.
В StarvationDemo показано, как работают потоки при Starvation и как одно маленькое изменение с Thread.sleep на Thread.wait в FairnessDemo позволяет распределить нагрузку равномерно.

# 4. Race Condition 
При работе с многопоточностью есть такое понятие, как "состояние гонки". Это явление заключается в том, что потоки делят между собой некоторый ресурс и код написан таким образом, что не предусматривает корректную работу в таком случае.
Этот код может выдать ошибку не с первого раза. И выглядеть она может вот таким вот образом:

Exception in thread "Thread-1" java.lang.IllegalStateException: 7899 + 1 = 7901 <br />
at App.lambda$main$0(App.java:13) <br />
at java.lang.Thread.run(Thread.java:745) <br />

Как видно, пока присваивалось newValue что-то пошло не так, и newValue стало больше. Какой-то из потоков в состоянии гонки успел изменить value между этими двумя командам. Как мы видим, проявилась гонка между потоками. А теперь представьте, как важно не совершать похожие ошибки с денежными операциями...

# 5. Volatile 
Говоря про взаимодействие потоков стоит особо отметить ключевое слово volatile.

Самое интересное, что он с высокой долей вероятности не отработает. Новый поток не увидит изменения flag. Чтобы это исправить для поля flag нужно указать ключевое слово volatile. Как же так и почему?

Все действия выполняет процессор. Но результаты вычислений нужно где-то хранить. Для этого есть основная память и есть аппаратный кэш у процессора. Эти кэши процессора — своего рода маленький кусочек памяти для более быстрого обращения к данным, чем обращения к основной памяти. Но у всего есть и минус: данные в кэше могут быть не актуальны (как в примере выше, когда значение флага не обновилось). Так вот, ключевое слово volatile указывает JVM, что мы не хотим кэшировать нашу переменную. Это позволяет увидеть актуальный результат во всех потоках.
Кроме того, важно помнить, что volatile — это про видимость, а не про атомарность измений.

# 6. Атомарность - Atomicity
Атомарные операции — это операции, которые нельзя разделить.

Например, операция присваивания значения переменной — атомарная.

К сожалению, инкремент не является атомарной операцией, т.к. для инкремента требуется аж три операции: получить старое значение, прибавить к нему единицу, сохранить значение.

Почему важна атомарность? В примере с инкрементом, если появится состояние гонки, в любой момент общий ресурс (т.е. общее значение) может внезапно измениться.

Кроме того, важно, что 64-битные структуры тоже не атомарны, например long и double. 

Специальный класс для работы с атомарным Integer всегда будет выводить нам 30000, а вот value будет меняться от раза к разу.
